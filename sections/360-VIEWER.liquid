{% schema %}
{
  "name": "Canvas 360 Viewer",
  "settings": [],
  "presets": [
    {
      "name": "Canvas 360 Rolex Style"
    }
  ]
}
{% endschema %}

<style>
  .canvas-360-wrapper {
    position: relative;
    width: 100%;
    max-width: 1100px;
    aspect-ratio: 1 / 1.2;
    background: #000 !important;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: auto;
  }

  canvas#watch360Canvas {
    display: block;
    width: 100% !important;
    height: auto !important;
    max-height: 80vh;
    background: #000 !important;
    border-radius: 12px;
  }

  @media (max-width: 700px) {
    .canvas-360-wrapper {
      aspect-ratio: 1 / 1.2;
      max-width: 100vw;
    }

    canvas#watch360Canvas {
      border-radius: 8px;
    }
  }
</style>

<div class="canvas-360-wrapper">
  <canvas id="watch360Canvas"></canvas>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const frameCount = 54;
    const canvas = document.getElementById("watch360Canvas");
    const context = canvas.getContext("2d");
    const images = [];
    let currentFrame = 0;
    let lastTime = 0;
    const fps = 30;
    const interval = 1000 / fps;
    const spinSpeed = 0.2;

    const imagePath = i => `https://cdn.shopify.com/s/files/1/0333/0936/0264/files/1020_360_${i + 1}.jpg`;

    const preloadImages = () => {
      return Promise.all(
        [...Array(frameCount)].map((_, i) => {
          return new Promise(resolve => {
            const img = new Image();
            img.src = imagePath(i);
            img.onload = () => resolve(img);
          });
        })
      );
    };

    function getWrapperDimensions() {
      const wrapper = document.querySelector('.canvas-360-wrapper');
      const rect = wrapper.getBoundingClientRect();
      return { width: rect.width, height: rect.height };
    }

    function resizeCanvas() {
      const { width, height } = getWrapperDimensions();
      const dpr = window.devicePixelRatio || 1;

      canvas.width = width * dpr;
      canvas.height = height * dpr;

      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';

      context.setTransform(dpr, 0, 0, dpr, 0, 0);
      drawFrame(Math.floor(currentFrame));
    }

    const drawFrame = (index) => {
      const img = images[index];
      if (!img) return;

      const canvasWidth = canvas.width;
      const canvasHeight = canvas.height;

      // Fill canvas with black
      context.fillStyle = "#000000";
      context.fillRect(0, 0, canvasWidth, canvasHeight);

      // Calculate image size while preserving aspect ratio
      const imgRatio = img.width / img.height;
      const canvasRatio = canvasWidth / canvasHeight;

      let drawWidth, drawHeight;
      if (imgRatio > canvasRatio) {
        drawWidth = canvasWidth;
        drawHeight = canvasWidth / imgRatio;
      } else {
        drawHeight = canvasHeight;
        drawWidth = canvasHeight * imgRatio;
      }

      const x = (canvasWidth - drawWidth) / 2;
      const y = (canvasHeight - drawHeight) / 2;

      context.drawImage(img, x, y, drawWidth, drawHeight);
    };

    const rotateSpin = (timestamp) => {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;
      if (delta > interval) {
        currentFrame = (currentFrame + spinSpeed) % frameCount;
        drawFrame(Math.floor(currentFrame));
        lastTime = timestamp;
      }
      requestAnimationFrame(rotateSpin);
    };

    preloadImages().then(loaded => {
      images.push(...loaded);
      resizeCanvas();
      rotateSpin(performance.now());
    });

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);
  });
</script>


