{% schema %}
{
  "name": "Canvas 360 Viewer",
  "settings": [],
  "presets": [
    {
      "name": "Canvas 360 Rolex Style"
    }
  ]
}
{% endschema %}
<style>
  .canvas-360-wrapper {
    position: relative;
    width: 100%;
    max-width: 1100px;
    background: #FFF !important;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: auto;
    box-sizing: border-box;
    /* Flexible height based on content */
    height: 0;
    padding-bottom: 125%; /* Default 4:5 ratio */
  }
  
  canvas#watch360Canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    display: block;
    filter: drop-shadow(0 30px 40px rgba(0,0,0,0.15));
    background: transparent;
    box-sizing: border-box;
    object-fit: contain;
    border-radius: 12px;
  }
  
  @media (max-width: 700px) {
    .canvas-360-wrapper {
      max-width: 100vw;
      padding-bottom: 100%; /* More square aspect ratio for mobile */
    }
    canvas#watch360Canvas {
      border-radius: 8px;
    }
  }
</style>

<div class="canvas-360-wrapper">
  <canvas id="watch360Canvas"></canvas>
</div>
<script>
document.addEventListener("DOMContentLoaded", function() {
  // Configuration
  const frameCount = 54;
  const targetFPS = 60;
  const baseSpinSpeed = 0.15; // Reduced from 0.5 to 0.15 for slower spin
  let qualityMode = 'high';
  let isMobile = window.matchMedia("(max-width: 700px)").matches;

  // Canvas setup
  const canvas = document.getElementById("watch360Canvas");
  const context = canvas.getContext("2d", { willReadFrequently: false });
  const images = [];
  
  // High-quality rendering setup
  const pixelRatio = window.devicePixelRatio || 1;
  canvas.style.width = '100%';
  canvas.style.height = '100%';
  
  // Animation state
  let currentFrame = 0;
  let lastTime = performance.now();

  // 1. Improved Image Loading with Quality Assurance
  const loadImage = (i) => {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.crossOrigin = "Anonymous";
      img.src = `https://cdn.shopify.com/s/files/1/0333/0936/0264/files/1020_360_${i + 1}.jpg?quality=100`;
      img.onload = () => {
        if (img.naturalWidth > 500) { // Quality check
          resolve(img);
        } else {
          reject(`Low quality image (frame ${i})`);
        }
      };
      img.onerror = () => reject(`Failed to load frame ${i}`);
    });
  };

  // 2. High-Quality Rendering with Retina Support
  const setupCanvas = () => {
    const wrapper = canvas.parentElement;
    const width = wrapper.clientWidth;
    const height = wrapper.clientHeight;
    
    // Set internal canvas size (scaled for retina)
    canvas.width = width * pixelRatio;
    canvas.height = height * pixelRatio;
    
    // Scale context to compensate for high DPI
    context.scale(pixelRatio, pixelRatio);
    context.imageSmoothingEnabled = true;
    context.imageSmoothingQuality = 'high';
  };

  // 3. Optimized Frame Drawing with Motion Blur Effect
  const drawFrame = () => {
    const frameIndex = Math.floor(currentFrame) % frameCount;
    const nextFrameIndex = (frameIndex + 1) % frameCount;
    const blendAmount = currentFrame % 1;
    
    const img = images[frameIndex];
    const nextImg = images[nextFrameIndex];
    
    if (!img || !nextImg) return;
    
    // Clear canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate dimensions (maintain aspect ratio)
    const imgRatio = img.naturalWidth / img.naturalHeight;
    const canvasDisplayWidth = canvas.width / pixelRatio;
    const canvasDisplayHeight = canvas.height / pixelRatio;
    const canvasRatio = canvasDisplayWidth / canvasDisplayHeight;
    
    let width, height, x, y;
    
    if (imgRatio > canvasRatio) {
      width = canvasDisplayWidth;
      height = width / imgRatio;
      x = 0;
      y = (canvasDisplayHeight - height) / 2;
    } else {
      height = canvasDisplayHeight;
      width = height * imgRatio;
      x = (canvasDisplayWidth - width) / 2;
      y = 0;
    }
    
    // Draw with motion blur effect between frames
    context.globalAlpha = 1 - (blendAmount * 0.3); // Reduced blend for sharper image
    context.drawImage(img, x, y, width, height);
    
    context.globalAlpha = blendAmount * 0.3;
    context.drawImage(nextImg, x, y, width, height);
    
    context.globalAlpha = 1;
  };

  // 4. Smooth Animation Loop with Dynamic Speed Control
  const animate = (timestamp) => {
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Adjust speed based on frame rate to maintain consistency
    const adjustedSpeed = baseSpinSpeed * (deltaTime / 16.67);
    currentFrame = (currentFrame + adjustedSpeed) % frameCount;
    
    drawFrame();
    requestAnimationFrame(animate);
  };

  // 5. Initialize with Quality Checks
  const init = async () => {
    setupCanvas();
    
    try {
      // Load all frames with progress feedback
      for (let i = 0; i < frameCount; i++) {
        try {
          const img = await loadImage(i);
          images[i] = img;
        } catch (e) {
          console.warn(e);
          // Fallback to previous frame if loading fails
          images[i] = images[Math.max(0, i-1)] || new Image();
        }
      }
      
      // Start animation
      animate(performance.now());
      
      // Handle resize
      window.addEventListener('resize', () => {
        setupCanvas();
        drawFrame();
      });
      
    } catch (error) {
      console.error("Initialization failed:", error);
    }
  };

  // Start the viewer
  init();
});
</script>