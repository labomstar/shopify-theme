{% schema %}
{
  "name": "Canvas 360 Viewer",
  "settings": [],
  "presets": [
    {
      "name": "Canvas 360 Rolex Style"
    }
  ]
}
{% endschema %}
<style>
  .canvas-360-wrapper {
    position: relative;
    width: 100%;
    max-width: 1100px;
    background: #FFF !important;
    display: flex;
    align-items: center;
    justify-content: center;
    margin: auto;
    box-sizing: border-box;
    /* Flexible height based on content */
    height: 0;
    padding-bottom: 125%; /* Default 4:5 ratio */
  }
  
  canvas#watch360Canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100% !important;
    height: 100% !important;
    display: block;
    filter: drop-shadow(0 30px 40px rgba(0,0,0,0.15));
    background: transparent;
    box-sizing: border-box;
    object-fit: contain;
    border-radius: 12px;
  }
  
  @media (max-width: 700px) {
    .canvas-360-wrapper {
      max-width: 100vw;
      padding-bottom: 100%; /* More square aspect ratio for mobile */
    }
    canvas#watch360Canvas {
      border-radius: 8px;
    }
  }
</style>

<div class="canvas-360-wrapper">
  <canvas id="watch360Canvas"></canvas>
</div>
<script>
document.addEventListener("DOMContentLoaded", function() {
  // Configuration
  const frameCount = 54;
  const targetFPS = 60; // Increased from 30 for smoother animation
  const frameInterval = 1000 / targetFPS;
  const baseSpinSpeed = 0.5; // Increased base speed
  let dynamicSpinSpeed = baseSpinSpeed;
  let qualityMode = 'high'; // 'high' or 'low' (auto-switches on mobile)

  // Canvas setup
  const canvas = document.getElementById("watch360Canvas");
  const context = canvas.getContext("2d");
  const images = [];
  
  // Animation state
  let currentFrame = 0;
  let lastTime = performance.now();
  let frameDelta = 0;
  let isMobile = window.matchMedia("(max-width: 700px)").matches;

  // 1. Improved Image Loading with Quality Detection
  const imagePath = i => {
    const base = `https://cdn.shopify.com/s/files/1/0333/0936/0264/files/1020_360_${i + 1}`;
    return qualityMode === 'high' ? `${base}.jpg` : `${base}_mobile.jpg`;
  };

  // 2. Frame Blending Function
  const drawBlendedFrames = (frameIndex, blendRatio) => {
    const frame1 = Math.floor(frameIndex) % frameCount;
    const frame2 = (frame1 + 1) % frameCount;
    
    const img1 = images[frame1];
    const img2 = images[frame2];
    
    if (!img1 || !img2) return;
    
    // Clear canvas
    context.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw first image
    context.globalAlpha = 1 - blendRatio;
    drawSingleFrame(frame1);
    
    // Draw second image with opacity blend
    context.globalAlpha = blendRatio;
    drawSingleFrame(frame2);
    
    // Reset alpha
    context.globalAlpha = 1;
  };

  // 3. Single Frame Drawing (optimized)
  const drawSingleFrame = (index) => {
    const img = images[index];
    if (!img) return;

    const imgRatio = img.naturalWidth / img.naturalHeight;
    const canvasRatio = canvas.width / canvas.height;

    let drawWidth, drawHeight, x, y;

    if (imgRatio > canvasRatio) {
      drawWidth = canvas.width;
      drawHeight = drawWidth / imgRatio;
      x = 0;
      y = (canvas.height - drawHeight) / 2;
    } else {
      drawHeight = canvas.height;
      drawWidth = drawHeight * imgRatio;
      x = (canvas.width - drawWidth) / 2;
      y = 0;
    }

    context.drawImage(img, x, y, drawWidth, drawHeight);
  };

  // 4. Adaptive Rendering
  const animate = (timestamp) => {
    // Calculate time since last frame
    const deltaTime = timestamp - lastTime;
    lastTime = timestamp;
    
    // Adjust quality based on performance
    if (deltaTime > 34) { // If frame took >34ms (â‰ˆ29fps)
      qualityMode = 'low';
    } else {
      qualityMode = 'high';
    }
    
    // Smooth speed adjustment
    const targetSpeed = isMobile ? baseSpinSpeed * 0.8 : baseSpinSpeed;
    dynamicSpinSpeed += (targetSpeed - dynamicSpinSpeed) * 0.1;
    
    // Calculate fractional frame position
    currentFrame = (currentFrame + dynamicSpinSpeed) % frameCount;
    const blendRatio = currentFrame % 1;
    
    // Use frame blending for smoother transitions
    drawBlendedFrames(currentFrame, blendRatio);
    
    requestAnimationFrame(animate);
  };

  // 5. Setup and Initialization
  const setup = async () => {
    // Load images
    await Promise.all(Array.from({length: frameCount}, (_, i) => {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = imagePath(i);
      });
    })).then(loaded => images.push(...loaded));
    
    // Start animation
    animate(performance.now());
    
    // Add mouse/touch controls
    setupUserControls();
  };

  // 6. User Controls for Manual Spin
  const setupUserControls = () => {
    let isInteracting = false;
    let lastX = 0;
    
    // Touch events
    canvas.addEventListener('touchstart', (e) => {
      isInteracting = true;
      lastX = e.touches[0].clientX;
      e.preventDefault();
    });
    
    canvas.addEventListener('touchmove', (e) => {
      if (!isInteracting) return;
      const deltaX = e.touches[0].clientX - lastX;
      currentFrame = (currentFrame - deltaX * 0.2) % frameCount;
      lastX = e.touches[0].clientX;
      e.preventDefault();
    });
    
    canvas.addEventListener('touchend', () => {
      isInteracting = false;
    });
    
    // Mouse events
    canvas.addEventListener('mousedown', (e) => {
      isInteracting = true;
      lastX = e.clientX;
    });
    
    canvas.addEventListener('mousemove', (e) => {
      if (!isInteracting) return;
      const deltaX = e.clientX - lastX;
      currentFrame = (currentFrame - deltaX * 0.2) % frameCount;
      lastX = e.clientX;
    });
    
    canvas.addEventListener('mouseup', () => {
      isInteracting = false;
    });
    
    canvas.addEventListener('mouseleave', () => {
      isInteracting = false;
    });
  };

  // Initialize
  setup();
});
</script>