<style>
  .canvas-360-wrapper {
    position: relative;
    width: 100%;
    max-width: 800px; /* Optimal watch display size */
    margin: 0 auto;
    background: #FFF;
    aspect-ratio: 4/5; /* Perfect watch proportion */
  }
  
  #watch360Canvas {
    width: 100%;
    height: 100%;
    display: block;
    background: transparent;
    image-rendering: crisp-edges; /* Sharp rendering */
  }
</style>

<div class="canvas-360-wrapper">
  <canvas id="watch360Canvas"></canvas>
  <div class="loading-message">Loading watch...</div>
</div>

<script>
document.addEventListener("DOMContentLoaded", function() {
  // 1. Stable Configuration
  const config = {
    frameCount: 54,
    spinSpeed: 0.4, // Perfect watch rotation speed
    imageBasePath: 'https://cdn.shopify.com/s/files/1/0333/0936/0264/files/',
    targetFPS: 60
  };

  // 2. DOM Elements
  const canvas = document.getElementById('watch360Canvas');
  const ctx = canvas.getContext('2d');
  const loadingMessage = document.querySelector('.loading-message');
  
  // 3. State Management
  const state = {
    images: [],
    currentFrame: 0,
    lastTime: performance.now(),
    loadingProgress: 0,
    ready: false
  };

  // 4. Proper Canvas Setup
  function setupCanvas() {
    const wrapper = canvas.parentElement;
    const pixelRatio = Math.min(window.devicePixelRatio, 2); // Limit to 2x for performance
    
    // Set internal canvas size
    canvas.width = wrapper.clientWidth * pixelRatio;
    canvas.height = wrapper.clientHeight * pixelRatio;
    
    // Scale context for sharp rendering
    ctx.scale(pixelRatio, pixelRatio);
    ctx.imageSmoothingEnabled = true;
  }

  // 5. Reliable Image Loading
  function loadImages() {
    let loadedCount = 0;
    
    const loadSingleImage = (index) => {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          state.images[index] = img;
          loadedCount++;
          state.loadingProgress = loadedCount / config.frameCount;
          loadingMessage.textContent = `Loading ${Math.round(state.loadingProgress * 100)}%`;
          resolve();
        };
        img.onerror = () => {
          console.warn(`Failed to load frame ${index+1}`);
          // Create blank frame if image fails to load
          state.images[index] = createBlankFrame(index);
          loadedCount++;
          resolve();
        };
        img.src = `${config.imageBasePath}1020_360_${index+1}.jpg?${Date.now()}`;
      });
    };
    
    // Load images sequentially for stability
    const loadSequentially = async (index = 0) => {
      if (index >= config.frameCount) {
        state.ready = true;
        loadingMessage.style.display = 'none';
        return;
      }
      await loadSingleImage(index);
      await loadSequentially(index + 1);
    };
    
    loadSequentially();
  }

  function createBlankFrame(index) {
    const canvas = document.createElement('canvas');
    canvas.width = 800;
    canvas.height = 1000;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#f5f5f5';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = '#ccc';
    ctx.font = '20px Arial';
    ctx.textAlign = 'center';
    ctx.fillText(`Frame ${index+1}`, canvas.width/2, canvas.height/2);
    return canvas;
  }

  // 6. Stable Frame Rendering
  function drawFrame() {
    if (!state.ready || state.images.length === 0) return;
    
    const frameIndex = Math.floor(state.currentFrame) % config.frameCount;
    const img = state.images[frameIndex];
    
    if (!img) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Calculate dimensions (maintain aspect ratio)
    const displayWidth = canvas.width / (window.devicePixelRatio || 1);
    const displayHeight = canvas.height / (window.devicePixelRatio || 1);
    const imgRatio = img.width / img.height;
    const canvasRatio = displayWidth / displayHeight;
    
    let width, height, x, y;
    
    if (imgRatio > canvasRatio) {
      // Fit to width
      width = displayWidth;
      height = width / imgRatio;
      x = 0;
      y = (displayHeight - height) / 2;
    } else {
      // Fit to height
      height = displayHeight;
      width = height * imgRatio;
      x = (displayWidth - width) / 2;
      y = 0;
    }
    
    // Draw image
    ctx.drawImage(img, x, y, width, height);
  }

  // 7. Smooth Animation Loop
  function animate(currentTime) {
    if (!state.lastTime) state.lastTime = currentTime;
    const deltaTime = currentTime - state.lastTime;
    state.lastTime = currentTime;
    
    // Consistent frame advance regardless of FPS
    state.currentFrame += config.spinSpeed * (deltaTime / (1000 / config.targetFPS));
    
    drawFrame();
    requestAnimationFrame(animate);
  }

  // 8. Initialize Viewer
  function init() {
    setupCanvas();
    loadImages();
    animate(performance.now());
    
    window.addEventListener('resize', () => {
      setupCanvas();
      drawFrame();
    });
  }

  // Start the viewer
  init();
});
</script>