{% schema %}
{
  "name": "Canvas 360 Viewer",
  "settings": [],
  "presets": [
    {
      "name": "Canvas 360 Rolex Style"
    }
  ]
}
{% endschema %}

<style>
  .canvas-360-wrapper {
    position: relative;
    width: 100vw;
    max-width: 1100px;
    height: 80vh;
    background: linear-gradient(to bottom, #f4f5f9 0%, #ffffff 100%);
    display: flex;
    align-items: center;
    justify-content: center;
    margin: auto;
  }
  canvas#watch360Canvas {
    width: 100%;
    height: 100%;
    display: block;
    filter: drop-shadow(0 30px 40px rgba(0, 0, 0, 0.15));
    background: transparent;
  }
</style>

<div class="canvas-360-wrapper">
  <canvas id="watch360Canvas"></canvas>
</div>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    const frameCount = 54;
    const canvas = document.getElementById("watch360Canvas");
    const context = canvas.getContext("2d");
    const images = [];
    const imageCenters = [];
    let currentFrame = 0;
    let lastTime = 0;
    const fps = 30;
    const interval = 1000 / fps;
    const spinSpeed = 0.2; // Adjust for faster/slower spin

    // Default background color: #f4f5f9 (adjust if needed)
    const backgroundColor = [244, 245, 249];
    const tolerance = 20; // Higher number = more tolerant, adjust if needed

    const imagePath = i => `https://cdn.shopify.com/s/files/1/0333/0936/0264/files/1020_360_${i + 1}.jpg`;

    function getImageCenter(img, bgColor = backgroundColor) {
      const tempCanvas = document.createElement('canvas');
      tempCanvas.width = img.width;
      tempCanvas.height = img.height;
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.drawImage(img, 0, 0);
      const data = tempCtx.getImageData(0, 0, img.width, img.height).data;

      let sumX = 0, sumY = 0, count = 0;
      for (let y = 0; y < img.height; y++) {
        for (let x = 0; x < img.width; x++) {
          const idx = (y * img.width + x) * 4;
          const r = data[idx], g = data[idx + 1], b = data[idx + 2];
          if (
            Math.abs(r - bgColor[0]) > tolerance ||
            Math.abs(g - bgColor[1]) > tolerance ||
            Math.abs(b - bgColor[2]) > tolerance
          ) {
            sumX += x;
            sumY += y;
            count++;
          }
        }
      }
      if (count === 0) {
        // fallback: center of image
        return { x: img.width / 2, y: img.height / 2 };
      }
      return { x: sumX / count, y: sumY / count };
    }

    function preloadImages() {
      return Promise.all(
        [...Array(frameCount)].map((_, i) => {
          return new Promise(resolve => {
            const img = new Image();
            img.src = imagePath(i);
            img.onload = () => resolve(img);
            img.onerror = () => {
              console.error("Image failed to load:", img.src);
              resolve(null);
            };
          });
        })
      );
    }

    const drawFrame = (index) => {
      const img = images[index];
      const center = imageCenters[index];
      if (!img || !center) return;

      // Fit image to canvas
      const canvasRatio = canvas.width / canvas.height;
      const imgRatio = img.width / img.height;

      let drawWidth, drawHeight;
      if (imgRatio > canvasRatio) {
        drawWidth = canvas.width;
        drawHeight = canvas.width / imgRatio;
      } else {
        drawHeight = canvas.height;
        drawWidth = canvas.height * imgRatio;
      }

      // Offset so the detected watch center aligns with canvas center
      const offsetX = (canvas.width / 2) - (center.x * (drawWidth / img.width));
      const offsetY = (canvas.height / 2) - (center.y * (drawHeight / img.height));

      context.clearRect(0, 0, canvas.width, canvas.height);
      context.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);
    };

    function resizeCanvas() {
      const maxWidth = 1100;
      const maxHeight = 1336;
      const ratio = maxWidth / maxHeight;
      let width = Math.min(window.innerWidth, maxWidth);
      let height = width / ratio;
      if (height > window.innerHeight * 0.8) {
        height = window.innerHeight * 0.8;
        width = height * ratio;
      }
      canvas.width = width;
      canvas.height = height;
      drawFrame(Math.floor(currentFrame));
    }
    window.addEventListener('resize', resizeCanvas);

    const rotateSpin = (timestamp) => {
      if (!lastTime) lastTime = timestamp;
      const delta = timestamp - lastTime;

      if (delta > interval) {
        currentFrame = (currentFrame + spinSpeed) % frameCount;
        drawFrame(Math.floor(currentFrame));
        lastTime = timestamp;
      }
      requestAnimationFrame(rotateSpin);
    };

    preloadImages().then(loaded => {
      // Filter out failed images (nulls)
      const filtered = loaded.filter(img => !!img);
      if (filtered.length === 0) {
        console.error("No images loaded! Please check your image URLs.");
        return;
      }

      images.push(...filtered);

      // Calculate centers
      filtered.forEach((img, idx) => {
        const center = getImageCenter(img);
        imageCenters.push(center);
        // Uncomment for debugging:
        // console.log(`Frame ${idx + 1} center:`, center);
      });

      resizeCanvas();
      rotateSpin(performance.now());
    });
  });
</script>